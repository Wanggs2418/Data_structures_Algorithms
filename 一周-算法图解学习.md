## 算法图解

### 0.算法简介

算法运行多少时间和运行时间随列表增长而增加。

大 O 表示法，指出算法能够执行的操作数

- 简单查找：O(n)
- 二分查找：O(log n)
- 排序算法：O(n * logn)
- 选择排序：O($n^2$)

算法速度指的并非时间，而是操作数的增速。即谈论算法的速度时，一般看随着输入的增加，其运行时间将以什么样的速度增加。

#### **0.1二分查找**

输入是一个有序的元素列表

对于包含 $n$ 个元素的列表，用二分查找最多需要 $\log_2n$ 步，

#### **0.2旅行商问题-TSP**

描述：旅行商前往 5 个城市，同时确保旅途最短，需考虑前往这些城市可能的顺序

解决：O(n!)，记录最糟糕的运行时间。对于 5 个城市，其可能的排列方式有 5! = 120 种，对于 n 个城市则为 n!。

### 1.选择排序

#### **1.1数据结构-数组和链表**

数组在内存中紧密相连，元素的为值称为索引，如元素 20 位于索引 1 处。

链表在内存中可以任意放置

**中间插入元素**：链表的表现优于数组，链表只需修改前面元素指向的地址，而数组往往需要整体移动。

**数组和链表相关操作的运行时间**

- 读取：数组--O(1)；链表--O(n)
- 插入：数组--O(n)；链表--O(1)
- 删除：数组--O(n)；链表--O(1)

一般情况下，还是数组运用的较多。因为其支持随机访问，而链表只支持顺序访问。

#### 1.2选择排序

对学生的分数按照从大到小排序，做法是：

- 遍历整个列表，找出分数最高的学生，并将其添加到一个新的列表中
- 同上，找出分数第二高的学生也添加到新的列表中
- 最后形成一个新的有序列表

时间复杂度为：$O(n×n)=O(n^2)$，需要注意的是，随着排序进行，每次旧列表的检查元素越来越少。即第 1 次为 n，后续分别为 n-1，n-2，...，1。平均每次的检查时间为 $n/2$ ，运行时间计算为：$O(n/2×n)=O(n^2/2)$，但是大 O 表示法省略相关的常数，直接表示为 $O(n^2)$。

### 2.递归

循环可能使得程序的性能更高，而递归的程序可能更容易理解。编写递归函数，容易形成无限循环，因此必须告诉它何时停止递归。

每个递归函数分为两部分：

- 基线条件(base case) ：函数不再调用自身
- 递归条件 (recursive case)：函数调用自身

#### 2.1数据结构-栈

call stack，调用栈。栈虽然方便，但是也需要付出代价：储存的信息可能占用大量的内存。因为每个函数的调用都要占用一定的内存。

